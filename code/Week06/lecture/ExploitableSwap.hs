{-# LANGUAGE DataKinds           #-}
{-# LANGUAGE ImportQualifiedPost #-}
{-# LANGUAGE NoImplicitPrelude   #-}
{-# LANGUAGE OverloadedStrings   #-}
{-# LANGUAGE TemplateHaskell     #-}

module ExploitableSwap where

import           Plutus.V2.Ledger.Api      (ScriptContext (scriptContextTxInfo, ScriptContext), PubKeyHash, Validator, mkValidatorScript, adaToken, adaSymbol, singleton, ValidatorHash (ValidatorHash), TxInfo (txInfoInputs), TxInInfo (txInInfoOutRef, txInInfoResolved), TxOutRef (txOutRefId), TxOut (txOutAddress), Address (addressCredential), Credential (PubKeyCredential, ScriptCredential))
import           Plutus.V2.Ledger.Contexts (valuePaidTo, TxInfo, ownHash)
import           PlutusTx                  (compile, unstableMakeIsData)
import           PlutusTx.Builtins         (BuiltinData, Integer)
import           PlutusTx.Prelude          (Bool (..), (==), traceIfFalse, (&&), filter, ($), map, (.), length)
import           Utilities                 (wrapValidator)

---------------------------------------------------------------------------------------------------
----------------------------------- ON-CHAIN / VALIDATOR ------------------------------------------
{-
We will prevent double spending, by checking that 
only 1 output is being consumed by the Tx
-}

data DatumSwap = DatumSwap
  { beneficiary :: PubKeyHash
  , price       :: Integer
  }
PlutusTx.unstableMakeIsData ''DatumSwap

{-# INLINABLE mkValidator #-}
mkValidator :: DatumSwap -> () -> ScriptContext -> Bool
mkValidator ds _ ctx = traceIfFalse "Hey! You have to pay the owner!" outputToBeneficiary &&
  traceIfFalse "You must consume only one utxo" consumesOnlyOneUtxo
    where
        txInfo :: TxInfo
        txInfo = scriptContextTxInfo ctx

        outputToBeneficiary :: Bool
        outputToBeneficiary = 
          valuePaidTo txInfo (beneficiary ds) == singleton adaSymbol adaToken (price ds)



        consumesOnlyOneUtxo = length consumedInputsOfThisScript == 1
          where


            scriptAddress :: ValidatorHash
            scriptAddress = ownHash ctx

            -- The credentials that are required to unlock each input, can be either PubKeyHash,
            -- which means they belong to a user, and he unlocks them by signing with his pk,
            -- or ScriptCredentials, that require the script to be included, and validated
            inputScriptCredentials :: [Credential]
            inputScriptCredentials = map (addressCredential . txOutAddress . txInInfoResolved) $ txInfoInputs txInfo

            consumedInputsOfThisScript = filter protectedByThisScript inputScriptCredentials
              where
                protectedByThisScript :: Credential -> Bool
                protectedByThisScript c = case c of
                  PubKeyCredential _ -> False
                  ScriptCredential vh -> vh == scriptAddress




{-# INLINABLE  mkWrappedValidator #-}
mkWrappedValidator :: BuiltinData -> BuiltinData -> BuiltinData -> ()
mkWrappedValidator = wrapValidator mkValidator


validator :: Validator
validator = mkValidatorScript $$(compile [|| mkWrappedValidator ||])
